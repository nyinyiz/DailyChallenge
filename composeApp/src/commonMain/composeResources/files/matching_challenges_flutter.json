[
  {
    "question": "Match Flutter widgets with their purposes",
    "pairs": [
      {
        "left": "StatelessWidget",
        "right": "Immutable widget"
      },
      {
        "left": "StatefulWidget",
        "right": "Mutable widget with state"
      },
      {
        "left": "InheritedWidget",
        "right": "Propagates data down tree"
      },
      {
        "left": "Builder",
        "right": "Provides new BuildContext"
      }
    ],
    "difficulty": "Easy",
    "explanation": "Flutter uses different widget types for various UI building scenarios."
  },
  {
    "question": "Match layout widgets with their behaviors",
    "pairs": [
      {
        "left": "Column",
        "right": "Vertical layout"
      },
      {
        "left": "Row",
        "right": "Horizontal layout"
      },
      {
        "left": "Stack",
        "right": "Overlapping widgets"
      },
      {
        "left": "Expanded",
        "right": "Fills available space"
      }
    ],
    "difficulty": "Easy",
    "explanation": "Flutter provides various layout widgets for organizing child widgets."
  },
  {
    "question": "Match state management solutions with their approaches",
    "pairs": [
      {
        "left": "Provider",
        "right": "InheritedWidget wrapper"
      },
      {
        "left": "BLoC",
        "right": "Stream-based pattern"
      },
      {
        "left": "Riverpod",
        "right": "Compile-safe Provider"
      },
      {
        "left": "GetX",
        "right": "Reactive state management"
      }
    ],
    "difficulty": "Medium",
    "explanation": "Flutter offers multiple state management solutions for different needs."
  },
  {
    "question": "Match navigation methods with their uses",
    "pairs": [
      {
        "left": "push",
        "right": "Adds route to stack"
      },
      {
        "left": "pop",
        "right": "Removes current route"
      },
      {
        "left": "pushReplacement",
        "right": "Replaces current route"
      },
      {
        "left": "pushNamed",
        "right": "Navigates using route name"
      }
    ],
    "difficulty": "Easy",
    "explanation": "Flutter's Navigator manages route stack for screen transitions."
  },
  {
    "question": "Match async programming concepts with Dart features",
    "pairs": [
      {
        "left": "Future",
        "right": "Represents eventual value"
      },
      {
        "left": "Stream",
        "right": "Sequence of async events"
      },
      {
        "left": "async",
        "right": "Marks asynchronous function"
      },
      {
        "left": "await",
        "right": "Waits for Future completion"
      }
    ],
    "difficulty": "Medium",
    "explanation": "Dart provides comprehensive async programming support for Flutter apps."
  },
  {
    "question": "Match lifecycle methods with their timing",
    "pairs": [
      {
        "left": "initState",
        "right": "Called when State created"
      },
      {
        "left": "build",
        "right": "Called to render widget"
      },
      {
        "left": "dispose",
        "right": "Called when State destroyed"
      },
      {
        "left": "didUpdateWidget",
        "right": "Called when widget config changes"
      }
    ],
    "difficulty": "Easy",
    "explanation": "StatefulWidget lifecycle methods control widget behavior at different stages."
  },
  {
    "question": "Match animation classes with their purposes",
    "pairs": [
      {
        "left": "AnimationController",
        "right": "Controls animation playback"
      },
      {
        "left": "Tween",
        "right": "Defines value range"
      },
      {
        "left": "Curve",
        "right": "Defines animation easing"
      },
      {
        "left": "AnimatedBuilder",
        "right": "Rebuilds on animation change"
      }
    ],
    "difficulty": "Medium",
    "explanation": "Flutter's animation system provides low-level control for custom animations."
  },
  {
    "question": "Match key types with their uses",
    "pairs": [
      {
        "left": "ValueKey",
        "right": "Uses value for identity"
      },
      {
        "left": "ObjectKey",
        "right": "Uses object identity"
      },
      {
        "left": "UniqueKey",
        "right": "Always unique key"
      },
      {
        "left": "GlobalKey",
        "right": "Unique across entire app"
      }
    ],
    "difficulty": "Hard",
    "explanation": "Keys help Flutter identify and preserve widget state during rebuilds."
  },
  {
    "question": "Match rendering concepts with their roles",
    "pairs": [
      {
        "left": "Widget",
        "right": "Immutable configuration"
      },
      {
        "left": "Element",
        "right": "Instantiation of widget in tree"
      },
      {
        "left": "RenderObject",
        "right": "Handles layout and painting"
      },
      {
        "left": "BuildContext",
        "right": "Location in widget tree"
      }
    ],
    "difficulty": "Hard",
    "explanation": "Flutter's three-tree architecture separates configuration, hierarchy, and rendering."
  },
  {
    "question": "Match testing types with their scopes",
    "pairs": [
      {
        "left": "Unit Test",
        "right": "Tests individual functions"
      },
      {
        "left": "Widget Test",
        "right": "Tests single widget"
      },
      {
        "left": "Integration Test",
        "right": "Tests complete app"
      },
      {
        "left": "Golden Test",
        "right": "Tests visual appearance"
      }
    ],
    "difficulty": "Medium",
    "explanation": "Flutter supports multiple testing approaches for different verification needs."
  }
]